const fs = require("fs");
const path = require("path");
/**
 * Para forzar abril el proyecto en Visual Studio Code
 */
const { exec } = require("child_process");

const projectRoot = "My-App";
const foldersToCreate = [
  "controllers",
  "routes",
  "public/css",
  "public/js",
  "public/img",
  "src/components",
  "src/views",
  "src/services",
];

function createFolderStructure(rootPath, folders) {
  folders.forEach((folder) => {
    const folderPath = path.join(rootPath, folder);
    fs.mkdirSync(folderPath, { recursive: true });
    console.log(`Created folder: ${folderPath}`);
  });
}

// Create the project root folder
fs.mkdirSync(projectRoot, { recursive: true });
console.log(`Created folder: ${projectRoot}`);

// Create the folder structure inside the project root
createFolderStructure(projectRoot, foldersToCreate);

/**
 * Creando servidor con express
 */
const serverCode = `
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3001;

// Middleware para servir archivos estáticos desde la carpeta "public"
app.use(express.static('public'));

// Ruta de ejemplo
app.get('/', (req, res) => {
  res.send('¡Hola, mundo!');
});

// Iniciar el servidor
app.listen(PORT, () => {
  console.log(\`Servidor escuchando en el puerto \${PORT}\`);
});
`;

fs.writeFileSync(path.join(projectRoot, "server.js"), serverCode);
console.log(`Created file: server.js`);

/**
 * Creando archivo README.MD
 */
const readmeContent = `- /My-App
- /node_modules
  - /controllers
  - /routes
  - /public
      - /css
      - /js
      - /img
  - /src
    - /components
    - /views
    - /services
  
- package-lock.json
- package.json
- .gitignore

- npm init -y
- npm install express
- npm i ejs

- node --watch server.js
- nodemon server.js
- npm start

- Para correr proyecto existente;
  npm i

- Instalar nodemon como dependencia de desarrollo
    npm i nodemon -D
- Instalar nodemon de forma global:
    npm install -g nodemon
    npm install nodemon --save-dev


`;

fs.writeFileSync(path.join(projectRoot, "README.md"), readmeContent);
console.log(`Created file: README.md`);

/**
 * Creando el archivo .gitignore
 */
const gitignoreContent = `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*`;

fs.writeFileSync(path.join(projectRoot, ".gitignore"), gitignoreContent);
console.log(`Created file: .gitignore`);

/**
 * Luego de crear todo el scaffolding (Estructura) de la aplicación,
 * forzar que la misma se habra desde Visual Studio Code
 */
// Obtener la ruta completa de la carpeta My-App
const projectPath = path.join(__dirname, "My-App");

// Abrir el proyecto en Visual Studio Code
exec(`code ${projectPath}`, (error, stdout, stderr) => {
  if (error) {
    console.error(`Error al abrir Visual Studio Code: ${error.message}`);
    return;
  }
  if (stderr) {
    console.error(`Error en la salida de Visual Studio Code: ${stderr}`);
    return;
  }
  console.log("Proyecto abierto en Visual Studio Code.");
});

/**
 * Eliminar el archivo create-project-structure.js luego de haber creado toda
 * la estructura del proyecto
 */
// Obtener la ruta completa del archivo create-project-structure.js

/*
const scriptPath = path.join(__dirname, "create-project-structure.js");
// Eliminar el archivo create-project-structure.js
fs.unlinkSync(scriptPath);
console.log("Archivo create-project-structure.js eliminado.");
*/
